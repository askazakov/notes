Дали задачку 

Выполните письменное задание. Можно гуглить, ориентир по времени – 25 минут
Есть класс
```csharp
class TreeNode
{
    public IEnumerable<TreeNode> Children { get; }
}
```

Напишите функцию

```csharp
IEnumerable<TreeNode> GetAllNodes(TreeNode node) {
    // тут надо написать код
}
```

Эта функция должна возвращать `IEnumerable<TreeNode>`, содержащий все элементы переданного в неё дерева, всех уровней вложенности.

Спрашиваю про порядок обхода, получаю ответ «на ваше усмотрение».

За отведённое время успеваю наколбасить [решение](https://github.com/askazakov/job-interview-1/commit/b21c931d0e404a36ff660516442dbd8baf2ccd5e), попутно размышляя о том, что `Aux` – ужасное имя, что «тестик» в Main – это убого и не позволит ничего поправить на ходу, так как не будет гарантии, что ничего не сломается – всё то, за что в своё время на собеседованиях мы журили испытуемых.

Ещё проскакивает мысль, что `List` повсюду плохо согласуется с IEnumerable и по красоте надо с `yield` сделать, но понимаю, что за 25 минут не успею.

Показываю решение, меня спрашивают, что в нём не очень. Я мямлю что-то невразумительное про разрастание стека и рекурсивные вызовы.

Просят написать тест для дерева из примера. Пишу 
```csharp
    var root = new TreeNode();
    var childA = new TreeNode();
    var childB = new TreeNode();
    root.Children = new List<TreeNode>() { childA, childB };
    var actual = GetAllNodes(root);
    actual.ToList() == new List<TreeNode>() { root, childB, childA };
```
сопроваждая ремаркой о том, что тут должен быть assert

Мне говорят, что такой ассёрт будет проваливаться.
Я невнятно говорю, что из-за сравнения массивов, и надо использовать какой-нибудь метод, который я на память не помню, но должен же быть в nUnit подобный. Или на худой конец в FluentAssertion.